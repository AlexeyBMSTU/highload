# Хабр
Репозиторий проекта Хабр для дисциплины Highload

# Проект Хабр

## Ключевой функционал сервиса:

    1. Создание и редактирование постов:
        Пользователи могут создавать новые посты, добавлять текст, изображения и теги.
        Возможность редактирования уже опубликованных постов.

    2. Комментирование постов:
        Пользователи могут оставлять комментарии под постами, что способствует обсуждению и взаимодействию.

    3. Лайки и реакции на посты и комментарии:
        Возможность ставить лайки и другие реакции на посты и комментарии, что позволяет пользователям выражать свое мнение.

    4. Поиск по постам и тегам:
        Функция поиска, позволяющая пользователям находить посты по ключевым словам и тегам.

    5. Профили пользователей:
        Каждый пользователь имеет свой профиль, где отображаются его посты, комментарии и другая активность.

    6. Подписка на пользователей и темы:
        Возможность подписываться на других пользователей и интересные темы, чтобы получать уведомления о новых постах.

    7. Уведомления:
        Система уведомлений о новых комментариях, лайках и ответах на посты, на которые подписан пользователь.

## Ключевые продуктовые решения:

    1. Хранение данных:
        Посты и комментарии хранятся на сервере, что позволяет пользователям получать доступ к контенту с разных устройств.

    2. Модерация контента:
        Внедрение системы модерации для предотвращения публикации нежелательного контента.

    3. Адаптивный интерфейс:
        Интерфейс, оптимизированный для различных устройств, чтобы обеспечить удобство использования.

    4. API для интеграции:
        Разработка API, позволяющего сторонним разработчикам интегрировать сервис с другими приложениями и платформами.

    5. Безопасность и аутентификация:
        Реализация безопасной системы аутентификации пользователей (например, через OAuth) и защита данных.

    6. Аналитика и статистика:
        Внедрение инструментов для сбора статистики о взаимодействии пользователей с контентом, что поможет в дальнейшем развитии сервиса.

## Продуктовые метрики

1. Месячная аудитория: Ожидаемое количество уникальных пользователей в месяц составляет 100,000.

2. Дневная аудитория: Ожидаемое количество уникальных пользователей в день составляет 10,000.

3. Средний размер хранилища пользователя: В среднем, каждый пользователь хранит 5 объектов и 2 гигабайта данных. Эти значения могут варьироваться в зависимости от типа контента, который пользователи загружают или создают.

4. Среднее количество действий пользователя в день: В среднем, каждый пользователь выполняет 20 действий в день. Это может включать, например, 10 запросов на поиск, 5 загрузок и 5 комментариев.

## Технические метрики

1. Размер хранения по типам данных: Общее количество объектов в системе составляет 500,000, а общий объем данных — 10 терабайт.

2. Пиковое потребление сетевого трафика: Максимальная скорость передачи данных в пиковые часы достигает 1.5 Гбит/с.

3. Суммарный суточный трафик: Общий объем переданных данных за сутки составляет 200 гигабайт.

4. RPS по типам запросов: Среднее количество запросов в секунду (RPS) составляет 50. Это может включать, например, 30 запросов на поиск, 10 на загрузку и 10 на комментарии. Пиковое значение RPS может достигать 100, с разбивкой на 60 запросов на поиск, 20 на загрузку и 20 на комментарии.

## Глобальная балансировка нагрузки
### Функциональное разбиение по доменам

При наличии нескольких доменов, функциональное разбиение может быть организовано следующим образом:

    1. Домен A: Основной функционал, связанный с пользовательским интерфейсом и взаимодействием с клиентами.
    2. Домен B: API для мобильных приложений и сторонних сервисов.
    3. Домен C: Административный интерфейс и инструменты для управления контентом.

Такое разбиение позволяет оптимизировать нагрузку и улучшить производительность, так как каждый домен может обслуживаться отдельными серверами или датацентрами.
Обоснования расположения дата-центров

### Расположение дата-центров (ДЦ) должно учитывать следующие факторы, влияющие на продуктовые метрики:

    1. Близость к пользователям: Дата-центры должны располагаться в регионах с высокой концентрацией целевой аудитории, чтобы минимизировать задержки и улучшить скорость отклика.
    
    2. Законодательные требования: В некоторых странах существуют строгие законы о хранении данных, которые могут требовать размещения данных на территории страны.
    
    3. Надежность и доступность: Выбор регионов с низким риском природных катастроф и высокой надежностью инфраструктуры.
    Сетевые соединения: Наличие высокоскоростных и надежных каналов связи для обеспечения быстрого доступа к данным.

### Расчет распределения запросов по типам запросов и датацентрам

На основе ранее представленных метрик, распределение запросов может выглядеть следующим образом:

    1. Запросы на поиск: 60% от общего объема запросов, распределенные между ДЦ1 и ДЦ2.
    2. Запросы на загрузку: 20% от общего объема запросов, преимущественно обрабатываемые в ДЦ1.
    3. Запросы на комментарии: 20% от общего объема запросов, распределенные между всеми ДЦ.

Пример распределения по датацентрам:

    1. ДЦ1: 50% от общего объема запросов.
    2. ДЦ2: 30% от общего объема запросов.
    3. ДЦ3: 20% от общего объема запросов.

### Схема DNS балансировки

Если используется DNS балансировка, схема может включать несколько записей A для одного домена, указывающих на IP-адреса различных дата-центров. DNS-сервер будет возвращать разные IP-адреса в зависимости от геолокации пользователя или нагрузки на серверы.

### Схема Anycast балансировки

Anycast позволяет направлять запросы к ближайшему дата-центру, используя один и тот же IP-адрес для всех дата-центров. Это достигается путем объявления одного и того же IP-адреса в разных регионах, что позволяет маршрутизаторам направлять трафик к ближайшему узлу.

### Механизм регулировки трафика между дата-центрами

Для регулировки трафика между дата-центрами могут использоваться следующие механизмы:

    1. Автоматическое масштабирование: В зависимости от нагрузки на серверы, система может автоматически добавлять или удалять ресурсы в разных дата-центрах.
    
    2. Мониторинг и анализ: Использование инструментов мониторинга для анализа производительности и нагрузки на каждый дата-центр, что позволяет принимать решения о перераспределении трафика.
    
    3. Ручное управление: Администраторы могут вручную регулировать распределение трафика в зависимости от текущих условий и потребностей.

## Логическая схема БД
    Таблица Users
        Поля:
            user_id (PK)
            username
            email
            password_hash
            created_at
        Связи:
            Один ко многим с таблицей Posts (один пользователь может иметь много постов).

    Таблица Posts
        Поля:
            post_id (PK)
            user_id (FK)
            title
            content
            created_at
        Связи:
            Один ко многим с таблицей Comments (один пост может иметь много комментариев).
            Многие ко многим с таблицей Tags (пост может иметь несколько тегов).

    Таблица Comments
        Поля:
            comment_id (PK)
            post_id (FK)
            user_id (FK)
            content
            created_at
        Связи:
            Один ко многим с таблицей Likes (один комментарий может иметь много лайков).

    Таблица Tags
        Поля:
            tag_id (PK)
            name
        Связи:
            Многие ко многим с таблицей Posts (один тег может быть связан с несколькими постами).

    Таблица Likes
        Поля:
            like_id (PK)
            comment_id (FK)
            user_id (FK)
            created_at
        Связи:
            Один ко многим с таблицей Users (один пользователь может лайкнуть много комментариев).

    Таблица Files
        Поля:
            file_id (PK)
            user_id (FK)
            file_path
            created_at
        Связи:
            Один ко многим с таблицей Users (один пользователь может загрузить много файлов).

    Таблица Caches
        Поля:
            cache_id (PK)
            key
            value
            expiration
        Связи:
            Нет.

    Таблица Buffers
        Поля:
            buffer_id (PK)
            data
            created_at
        Связи:
            Нет.

## Описание таблиц

Users: Эта таблица хранит информацию о пользователях. Ожидается, что в ней будет около 1,000,000 записей. Нагрузка на чтение будет высокой, а на запись — средней. Требования к консистентности высокие (ACID). Нагрузка распределяется по полю user_id.

Posts: Таблица содержит посты пользователей. Прогнозируется, что в ней будет около 5,000,000 записей. Нагрузка на чтение будет высокой, а на запись — высокой. Требования к консистентности также высокие (ACID). Нагрузка распределяется по полю post_id.

Comments: В этой таблице хранятся комментарии к постам. Ожидается, что в ней будет около 20,000,000 записей. Нагрузка на чтение будет высокой, а на запись — высокой. Требования к консистентности высокие (ACID). Нагрузка распределяется по полям post_id и comment_id.

Tags: Таблица хранит теги для постов. Прогнозируется, что в ней будет около 100,000 записей. Нагрузка на чтение будет средней, а на запись — низкой. Требования к консистентности средние. Нагрузка распределяется по полю tag_id.

Likes: Эта таблица содержит лайки к комментариям. Ожидается, что в ней будет около 50,000,000 записей. Нагрузка на чтение будет высокой, а на запись — высокой. Требования к консистентности высокие (ACID). Нагрузка распределяется по полю comment_id.

Files: Таблица хранит информацию о загруженных файлах. Прогнозируется, что в ней будет около 500,000 записей. Нагрузка на чтение будет средней, а на запись — средней. Требования к консистентности средние. Нагрузка распределяется по полю user_id.

Caches: Эта таблица хранит кэшированные данные. Ожидается, что в ней будет около 1,000,000 записей. Нагрузка на чтение будет высокой, а на запись — низкой. Требования к консистентности низкие (eventual consistency). Нагрузка распределяется по ключам.

Buffers: Таблица хранит временные данные для обработки. Ожидается, что в ней будет около 500,000 записей. Нагрузка на чтение будет средней, а на запись — средней. Требования к консистентности средние. Нагрузка распределяется по полю buffer_id.

## Физическая схеба БД
    Таблица Users
        Поля:
            user_id (PK, индекс)
            username (индекс)
            email (индекс)
            password_hash
            created_at
        Шардирование: По user_id.
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL (Write-Ahead Logging).

    Таблица Posts
        Поля:
            post_id (PK, индекс)
            user_id (FK, индекс)
            title
            content
            created_at
        Шардирование: По user_id.
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

    Таблица Comments
        Поля:
            comment_id (PK, индекс)
            post_id (FK, индекс)
            user_id (FK, индекс)
            content
            created_at
        Шардирование: По post_id.
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

    Таблица Tags
        Поля:
            tag_id (PK, индекс)
            name (индекс)
        Шардирование: Не требуется (малое количество записей).
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

    Таблица Likes
        Поля:
            like_id (PK, индекс)
            comment_id (FK, индекс)
            user_id (FK, индекс)
            created_at
        Шардирование: По comment_id.
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

    Таблица Files
        Поля:
            file_id (PK, индекс)
            user_id (FK, индекс)
            file_path
            created_at
        Шардирование: По user_id.
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

    Таблица Caches
        Поля:
            cache_id (PK, индекс)
            key (индекс)
            value
            expiration
        Шардирование: Не требуется (малое количество записей).
        СУБД: Redis.
        Резервирование: Резервная копия с использованием механизма AOF (Append-Only File).

    Таблица Buffers
        Поля:
            buffer_id (PK, индекс)
            data
            created_at
        Шардирование: Не требуется (малое количество записей).
        СУБД: PostgreSQL.
        Резервирование: Резервная копия на уровне базы данных с использованием WAL.

## Таблица с описанием таблиц

Users: Таблица хранит информацию о пользователях. Индексы: user_id, username, email. Используется PostgreSQL. Шардирование по user_id. Резервирование с использованием WAL.

Posts: Таблица содержит посты пользователей. Индексы: post_id, user_id. Используется PostgreSQL. Шардирование по user_id. Резервирование с использованием WAL.

Comments: Таблица хранит комментарии к постам. Индексы: comment_id, post_id, user_id. Используется PostgreSQL. Шардирование по post_id. Резервирование с использованием WAL.

Tags: Таблица хранит теги для постов. Индексы: tag_id, name. Используется PostgreSQL. Шардирование не требуется. Резервирование с использованием WAL.

Likes: Таблица содержит лайки к комментариям. Индексы: like_id, comment_id, user_id. Используется PostgreSQL. Шардирование по comment_id. Резервирование с использованием WAL.

**Files Files: Таблица хранит информацию о загруженных файлах. Индексы: file_id, user_id. Используется PostgreSQL. Шардирование по user_id. Резервирование с использованием WAL.

Caches: Таблица хранит кэшированные данные. Индексы: cache_id, key. Используется Redis. Шардирование не требуется. Резервирование с использованием механизма AOF.

Buffers: Таблица хранит временные данные для обработки. Индексы: buffer_id. Используется PostgreSQL. Шардирование не требуется. Резервирование с использованием WAL.

### Дополнительные требования

    Индексы: Все таблицы имеют первичные ключи и соответствующие индексы для оптимизации запросов.
    Денормализация: В некоторых случаях возможно использование денормализации для повышения производительности, например, в таблице Posts можно хранить количество лайков и комментариев.
    Клиентские библиотеки / интеграции: Для PostgreSQL можно использовать библиотеки, такие как psycopg2 или SQLAlchemy. Для Redis — библиотеку redis-py.
    Балансировка запросов / мультиплексирование подключений: Использование пула соединений для PostgreSQL, например, с помощью PgBouncer, для управления нагрузкой.
    Схема резервного копирования: Регулярное создание резервных копий с использованием инструментов, таких как pg_dump для PostgreSQL и встроенные механизмы Redis для AOF.
    
## Алгоритмы

| Алгоритм | Область применения | Мотивационная часть | 
Сортировка слиянием| Обработка и сортировка данных | Эффективен для больших объемов данных, имеет временную сложность O(n log n) и стабильность. |
| Алгоритм Дейкстры | Поиск кратчайшего пути в графах | Позволяет находить оптимальные маршруты в сетях, таких как GPS и компьютерные сети. | 
| Алгоритм Краскала | Минимальное остовное дерево | Используется для построения минимального остовного дерева в графах, что полезно в сетевых приложениях. | 
| Алгоритм A* | Поиск пути в графах | Эффективен для нахождения кратчайшего пути с учетом эвристики, широко используется в играх и робототехнике. | 
| Метод градиентного спуска | Оптимизация функций | Применяется в машинном обучении для минимизации функции потерь, что позволяет обучать модели. | 
| Алгоритм Флойда-Уоршелла | Поиск кратчайших путей между всеми парами вершин | Полезен для нахождения кратчайших путей в плотных графах, например, в транспортных системах. | 
| Алгоритм Кнута-Морриса-Пратта | Поиск подстроки в строке | Эффективен для поиска подстрок в текстах, используется в текстовых редакторах и поисковых системах. | 
| Алгоритм Бойера-Мура | Поиск подстроки в строке | Быстрый алгоритм для поиска подстрок, особенно эффективен для длинных текстов. | 
| Алгоритм Хаффмана | Сжатие данных | Используется для сжатия данных, например, в форматах изображений и аудио, обеспечивая эффективное хранение. | 
| Алгоритм Левенштейна | Сравнение строк | Применяется для вычисления расстояния редактирования между строками, полезен в обработке естественного языка. |

## Технологии
| Технология | Область применения | Мотивационная часть | 
| Markdown | Разметка текстов | Упрощает создание и форматирование контента, что позволяет авторам легко писать статьи и посты. | 
| Git | Системы контроля версий | Позволяет разработчикам отслеживать изменения в коде, сотрудничать и управлять проектами. | | Docker | Контейнеризация приложений | Упрощает развертывание и управление приложениями, что позволяет разработчикам легко тестировать и разворачивать свои проекты. | 
| Kubernetes | Оркестрация контейнеров | Автоматизирует управление контейнеризованными приложениями, что позволяет масштабировать и поддерживать высокую доступность. | 
| Python | Разработка программного обеспечения | Широко используется для создания веб-приложений, анализа данных и автоматизации, благодаря своей простоте и мощным библиотекам. | 
| JavaScript | Разработка веб-приложений | Является основным языком для создания интерактивных пользовательских интерфейсов в браузерах. | 
| PostgreSQL | Системы управления базами данных | Обеспечивает надежное и мощное решение для хранения и управления данными, поддерживая сложные запросы и транзакции. | 
| Redis | Кэширование и хранилище данных | Используется для повышения производительности приложений за счет быстрого доступа к данным. | 
| Jenkins | Непрерывная интеграция и развертывание | Автоматизирует процессы сборки и развертывания, что ускоряет разработку и повышает качество программного обеспечения. |

## Обеспечение надёжности
| Компонент системы | Способы резервирования |  
| Серверы приложений | - Использование кластеров для балансировки нагрузки и отказоустойчивости. <br> - Горизонтальное масштабирование (добавление дополнительных серверов). <br> - Резервное копирование конфигураций и данных. | 
| Базы данных | - Репликация данных (мастер-слейв, мастер-мастер). <br> - Регулярное создание резервных копий (бэкапов). <br> - Использование кластеров для обеспечения высокой доступности (например, PostgreSQL с Patroni). | 
| Хранилища данных | - Использование RAID-массивов для защиты от потери данных. <br> - Геораспределенное хранилище для защиты от локальных сбоев. <br> - Регулярное резервное копирование данных. | 
| Сетевые компоненты | - Использование резервных маршрутизаторов и коммутаторов. <br> - Настройка избыточных сетевых соединений (например, с помощью протоколов VRRP или HSRP). <br> - Мониторинг состояния сетевых устройств и автоматическое переключение на резервные. | 
| Системы кэширования | - Использование кластеров кэширования (например, Redis Sentinel). <br> - Регулярное резервное копирование кэшированных данных. <br> - Настройка избыточных узлов для обеспечения доступности. | 
| Системы очередей | - Использование кластеров для обработки сообщений (например, RabbitMQ с HA). <br> - Резервное копирование конфигураций и данных очередей. <br> - Настройка избыточных узлов для обеспечения доступности. | 
| Инфраструктура | - Использование облачных решений с автоматическим резервированием. <br> - Геораспределенные дата-центры для защиты от локальных сбоев. <br> - Регулярное тестирование восстановления после сбоев. | 
| Мониторинг и логирование | - Резервное копирование конфигураций мониторинга. <br> - Использование нескольких экземпляров систем мониторинга. <br> - Хранение логов в распределенных системах (например, ELK Stack). |

## Схема взаимодействия сервисов

    Клиентское приложение (веб или мобильное) отправляет запросы к API Gateway.

    API Gateway:
        Обрабатывает входящие запросы от клиентов.
        Выполняет аутентификацию и авторизацию.
        Направляет запросы к соответствующим микросервисам.
        Реализует внешнюю балансировку нагрузки, распределяя запросы между несколькими экземплярами микросервисов.

    Микросервисы:
        Сервис пользователей: управляет данными пользователей, аутентификацией и профилями.
        Сервис постов: отвечает за создание, редактирование и удаление постов.
        Сервис комментариев: обрабатывает комментарии к постам.
        Сервис лайков: управляет лайками к комментариям и постам.
        Сервис тегов: отвечает за создание и управление тегами для постов.
        Сервис файлов: обрабатывает загрузку и хранение файлов.

    База данных:
        Каждому микросервису соответствует своя база данных или схема в одной базе данных, что позволяет обеспечить независимость и гибкость.
        Микросервисы взаимодействуют с базами данных через ORM или прямые SQL-запросы.

    Система кэширования:
        Используется для хранения часто запрашиваемых данных (например, профили пользователей, посты) для уменьшения нагрузки на базы данных и ускорения ответов.
        Микросервисы обращаются к кэшу перед выполнением запросов к базе данных.

    Система очередей:
        Используется для обработки фоновых задач (например, отправка уведомлений, обработка изображений).
        Микросервисы отправляют сообщения в очередь, а фоновые рабочие процессы обрабатывают их асинхронно.

    Мониторинг и логирование:
        Все микросервисы отправляют метрики и логи в централизованную систему мониторинга (например, Prometheus, ELK Stack).
        Это позволяет отслеживать производительность и выявлять проблемы в реальном времени.

## Пояснения к схеме

    Потоки данных: 
        Данные проходят от клиентского приложения через API Gateway к соответствующим микросервисам. Каждый микросервис обрабатывает запросы и взаимодействует с базами данных и кэшами. Результаты возвращаются обратно через API Gateway к клиенту.

    Балансировка нагрузки:
        Внешняя балансировка: API Gateway распределяет входящие запросы между экземплярами микросервисов, обеспечивая равномерную нагрузку и высокую доступность.
        Внутренняя балансировка: Каждый микросервис может иметь несколько экземпляров, и запросы к ним могут распределяться с помощью таких инструментов, как Kubernetes или сервисы, такие как Consul.


